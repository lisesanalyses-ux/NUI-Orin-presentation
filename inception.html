<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <title>Architect | Large & Rotatable</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'JetBrains Mono', monospace; }
        #ui { position: absolute; top: 20px; left: 20px; color: #00f2ff; pointer-events: none; z-index: 10; }
        .hint { color: #555; font-size: 10px; margin-top: 5px; }
        .highlight { color: #d4af37; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">
        BLOCKS: <span id="count" class="highlight">0</span><br>
        ROTATION: <span id="rot-stat">IDLE</span>
        <div class="hint">DLAN DOLE VLEVO/VPRAVO = ROTACE | PINCH = STAVBA</div>
    </div>

    <script>
        let scene, camera, renderer, raycaster, world, planeMesh;
        let blocks = [], ghost, grabbed = null, isPinching = false;
        let currentHandPos = new THREE.Vector3();
        let rotY = 0;
        const blockSize = 1.5; // Zvětšené kostky

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 25); // Větší odstup pro větší kostky
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            world = new THREE.Group();
            scene.add(world);

            raycaster = new THREE.Raycaster();

            // Mřížka (upravená pro větší měřítko)
            const planeGeom = new THREE.PlaneGeometry(30, 30, 30, 30);
            planeGeom.rotateX(-Math.PI / 2);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x00f2ff, wireframe: true, transparent: true, opacity: 0.15 });
            planeMesh = new THREE.Mesh(planeGeom, planeMat);
            world.add(planeMesh);

            // Ghost Preview (větší)
            ghost = new THREE.Mesh(
                new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                new THREE.MeshBasicMaterial({ color: 0x00f2ff, wireframe: true, transparent: true, opacity: 0.4 })
            );
            world.add(ghost);

            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const light = new THREE.DirectionalLight(0xffffff, 0.8);
            light.position.set(10, 20, 10);
            scene.add(light);

            animate();
        }

        function updateWave() {
            const pos = planeMesh.geometry.attributes.position;
            const localHand = world.worldToLocal(currentHandPos.clone());
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const z = pos.getZ(i);
                const dist = Math.sqrt(Math.pow(x - localHand.x, 2) + Math.pow(z - localHand.z, 2));
                const depth = Math.exp(-Math.pow(dist, 2) / 10) * 1.5;
                pos.setY(i, -depth);
            }
            pos.needsUpdate = true;
        }

        function getTopY(x, z, ignore) {
            let y = blockSize / 2;
            blocks.forEach(b => {
                if (b !== ignore && Math.abs(b.position.x - x) < 0.1 && Math.abs(b.position.z - z) < 0.1) {
                    y = Math.max(y, b.position.y + blockSize);
                }
            });
            return y;
        }

        function animate() {
            requestAnimationFrame(animate);
            world.rotation.y += rotY;
            updateWave();
            renderer.render(scene, camera);
        }

        window.addEventListener('message', (e) => {
            if (e.data.type === 'HAND_MOVE') {
                const { x, y, landmarks } = e.data;
                const ndcX = (x / window.innerWidth) * 2 - 1;
                const ndcY = -(y / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera({ x: ndcX, y: ndcY }, camera);
                
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersect = new THREE.Vector3();
                
                if (raycaster.ray.intersectPlane(plane, intersect)) {
                    currentHandPos.copy(intersect);
                    const localPos = world.worldToLocal(intersect.clone());
                    
                    // Zarovnání na mřížku odpovídající blockSize
                    const gx = Math.round(localPos.x / blockSize) * blockSize;
                    const gz = Math.round(localPos.z / blockSize) * blockSize;
                    const gy = getTopY(gx, gz, grabbed);

                    if (landmarks) {
                        const dist = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));
                        const isPinchingNow = dist < 0.05;

                        // LOGIKA ROTACE: Otevřená dlan v dolních rozích
                        rotY = 0;
                        document.getElementById('rot-stat').innerText = "IDLE";
                        if (!isPinchingNow && y > window.innerHeight * 0.6) {
                            if (x < window.innerWidth * 0.25) {
                                rotY = -0.03;
                                document.getElementById('rot-stat').innerText = "LEFT ↺";
                            } else if (x > window.innerWidth * 0.75) {
                                rotY = 0.03;
                                document.getElementById('rot-stat').innerText = "RIGHT ↻";
                            }
                        }

                        // LOGIKA STAVBY
                        if (isPinchingNow) {
                            if (!isPinching) {
                                isPinching = true;
                                const hits = raycaster.intersectObjects(blocks);
                                if (hits.length > 0) {
                                    grabbed = hits[0].object;
                                } else {
                                    const b = new THREE.Mesh(
                                        new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                                        new THREE.MeshPhongMaterial({ color: 0x00f2ff, emissive: 0x00f2ff, emissiveIntensity: 0.3, transparent: true, opacity: 0.9 })
                                    );
                                    world.add(b);
                                    blocks.push(b);
                                    grabbed = b;
                                    document.getElementById('count').innerText = blocks.length;
                                }
                            }
                            if (grabbed) {
                                grabbed.position.x += (gx - grabbed.position.x) * 0.3;
                                grabbed.position.z += (gz - grabbed.position.z) * 0.3;
                                grabbed.position.y += (gy - grabbed.position.y) * 0.3;
                                ghost.visible = false;
                            }
                        } else {
                            if (isPinching && grabbed) {
                                grabbed.position.set(gx, gy, gz);
                            }
                            isPinching = false;
                            grabbed = null;
                            ghost.visible = true;
                            ghost.position.set(gx, gy, gz);
                        }
                    }
                }
            }
        });

        init();
    </script>
</body>
</html>